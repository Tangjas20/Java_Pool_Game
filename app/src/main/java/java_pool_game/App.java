/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package java_pool_game;
import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Point2D;
import javafx.scene.Scene;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;
import javafx.scene.Group;
import javafx.scene.canvas.Canvas;
import javafx.util.Pair;

import java.util.*;


public class App extends Application{
    private static final double KEY_FRAME_DURATION = 0.017;
    private List<Ball> ballsInPlay;
    private Ball cueBall;
    private Line currentLine;
    private List<Circle> circ;
    private String path = "config.json";
    public App(){
    }
    @Override
    public void start(Stage primaryStage){
        //Sets up the ConfigReader and reads from the path specified
        ConfigReader config = new ConfigReader(this.path);
        config.parse();
        this.ballsInPlay = config.returnBalls();
        primaryStage.setTitle("Pool_game");



        //Creates the JavaFX scene and paints background depending on config
        Group root = new Group();
        Scene scene = new Scene(root);
        scene.setFill(Paint.valueOf(config.returnBoardColour()));

        //Configure canvas to config size
        Canvas canvas = new Canvas(config.boardX(), config.boardY());

        for (Ball ball: ballsInPlay){
            if (ball.return_colour().equals("WHITE")){
                this.cueBall = ball;
            }
        }

        AnimationTimer timer = new AnimationTimer(){
            @Override
            public synchronized void handle(long now){
                root.getChildren().removeIf(Circle.class::isInstance);
                GeneratePockets Gen = new GeneratePockets();
                ArrayList<Pockets> pocketList = Gen.GeneratePocketList(config.boardX(), config.boardY(), (long) (config.getRadius()*1.7));
                //Changes pocket objects into Circle objects
                ArrayList<Circle> pockets = generatePocketsToCircles(pocketList);

                moveBall(cueBall);

                for(Ball ball : ballsInPlay) {
                    for (Ball ball1 : ballsInPlay) {
                        if (ball != ball1) {
                            Double xLen = Math.pow(ball1.getX() - ball.getX(), 2);
                            Double yLen = Math.pow(ball1.getY() - ball.getY(), 2);
                            Double EuclideanDistance = Math.sqrt(xLen + yLen);

                            if (EuclideanDistance <= ball.getRadius()*2.2) {
                                Point2D ballpoint = new Point2D(ball.getX(), ball.getY());
                                Point2D ballVelocity = new Point2D(ball.getVelocityX(), ball.getVelocityY());
                                Point2D cueBallPoint = new Point2D(ball1.getX(), ball1.getY());
                                Point2D cueBallVelocity = new Point2D(ball1.getVelocityX(), ball1.getVelocityY());
                                Pair<Point2D, Point2D> collision = calculateCollision(cueBallPoint, cueBallVelocity, ball1.getMass(), ballpoint, ballVelocity, ball.getMass());
                                Point2D cueBallPair = collision.getKey();
                                Point2D collisionBall = collision.getValue();
                                ball.setVelocityX(cueBallPair.getX());
                                ball.setVelocityY(cueBallPair.getY());
                                ball1.setVelocityX(collisionBall.getX());
                                ball1.setVelocityY(collisionBall.getY());
                            }
                            boundaryCheck(ball, config);
                            moveBall(ball);
                            ballsInPlay = checkBallInPocket(pocketList, ballsInPlay, config);

                        }
                    }
                }

                if(ballsInPlay.contains(cueBall) == false){
                    System.out.println( "Restarting app!" );
                    primaryStage.close();
                    Platform.runLater( () -> App.this.start( new Stage() ) );
                }
                if(ballsInPlay.size() == 1){
                    System.out.println("******************************************");
                    System.out.println("****************!!YOU WIN!!***************");
                    System.out.println("******************************************");
                }
                circ = generateCircle(ballsInPlay);
                root.getChildren().addAll(circ);
                root.getChildren().addAll(pockets);

            }
        };



        timer.start();

        //https://mkyong.com/javafx/javafx-animated-ball-example/
        //http://www.java2s.com/Code/Java/JavaFX/KeyFrameandTimelinebasedanimation.htm
        /*scene.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                System.out.println("mouse click detected! " + mouseEvent.getSource());
                System.out.println(cueBall.getX() +", " + cueBall.getY());
            }
        });
        scene.addEventFilter(MouseEvent.)
        */

        mouseEvents(root);
        primaryStage.setScene(scene);
        root.getChildren().add(canvas);
        primaryStage.show();

    }
    public static void main(String[] args){
        launch(args);
    }

    public static void boundaryCheck(Ball ball, ConfigReader config){
        if ((ball.posX) <= 0.0+ball.getRadius()){
            ball.setX(0.0+ball.getRadius());
            ball.setVelocityX(-ball.getVelocityX());
        }
        else if (ball.posX >= config.boardX()-ball.getRadius()){
            ball.setX(config.boardX()- (0.0 + ball.getRadius()));
            ball.setVelocityX(-ball.getVelocityX());
        }
        else if (ball.posY <= 0.0+ball.getRadius()){
            ball.setY(0.0+ball.getRadius());
            ball.setVelocityY(-ball.getVelocityY());
        }
        else if (ball.posY >= config.boardY()-ball.getRadius()){
            ball.setY(config.boardY()-(0.0+ball.getRadius()));
            ball.setVelocityY(-ball.getVelocityY());
        }
    }

    public static List<Ball> checkBallInPocket(ArrayList<Pockets> PocketList, List<Ball> ball, ConfigReader config){
        List<Ball> ballsInPlay = ball;
        int removalIndex = -1;
        for (Ball balls : ballsInPlay){
            for (Pockets pocket: PocketList){
                Double xLen = Math.pow(balls.getX() - pocket.getX(), 2);
                Double yLen = Math.pow(balls.getY() - pocket.getY(), 2);
                Double EuclideanDistance = Math.sqrt(xLen + yLen);

                if (EuclideanDistance <= balls.getRadius()*2) {
                    if(balls.return_colour().equals("RED")){
                        balls.loseLife();
                    }

                    else if (balls.return_colour().equals("BLUE")){
                       if (balls.getLife() == 2){
                           Boolean noBallInOriginalSpot = true;
                           for(Ball otherBalls: ballsInPlay){
                               Double xLength = Math.pow(otherBalls.getX() - balls.initialX, 2);
                               Double yLength = Math.pow(otherBalls.getY() - balls.initialY, 2);
                               Double EucDistance = Math.sqrt(xLen + yLen);

                               if(balls.getRadius()*2 <= EucDistance){
                                   noBallInOriginalSpot = false;
                               }
                           }

                           if (noBallInOriginalSpot = true) {
                               BlueAndCreatorBall test = (BlueAndCreatorBall) balls;
                               test.loseBallLife();
                               balls.setVelocityY(0.0);
                               balls.setVelocityX(0.0);
                           }
                           else{
                               BlueAndCreatorBall test = (BlueAndCreatorBall) balls;
                               test.loseBallLife();
                           }
                       }
                       else{
                           balls.loseLife();
                       }

                    }
                    else if(balls.return_colour().equals("WHITE")){
                        balls.loseLife();
                    }
                }
            }

        }
        //System.out.println(removalIndex);
            List<Ball> ball2 = new ArrayList<>();
            for (Ball ballTemp : ballsInPlay){
                if ((ballTemp.getLife() == 0) == false){
                    ball2.add(ballTemp);
                }
            }

        return ball2;
    }

    public static void moveBall(Ball ball){
        if (-0.05 < ball.getVelocityX() && ball.getVelocityX() < 0.05 ){
            ball.setVelocityX(0.00);
        }
        else {
            ball.posX -= ball.getVelocityX() / 50;
            ball.setVelocityX(ball.getVelocityX() - ball.getVelocityX() / 50);
        }

        if (-0.05 < ball.getVelocityY() && ball.getVelocityY() < 0.05 ){
            ball.setVelocityY(0.00);
        }
        else{
            ball.posY -= ball.getVelocityY()/50;
            ball.setVelocityY(ball.getVelocityY()-ball.getVelocityY()/50);
        }
    }
    public void mouseEvents(Group root){

        root.setOnMousePressed(e -> {
            if (currentLine == null) {
                Double xLen = Math.pow(cueBall.getX() - e.getX(), 2);
                Double yLen = Math.pow(cueBall.getY() - e.getY(), 2);
                Double EuclideanDistance = Math.sqrt(xLen + yLen);
                if(EuclideanDistance < cueBall.getRadius()*2) {
                    currentLine = new Line(cueBall.getX(), cueBall.getY(), e.getX(), e.getY());
                    root.getChildren().add(currentLine);
                }
            } else {
                currentLine = null ;
            }
        });

        root.setOnMouseDragged(e -> {
            if (currentLine != null) {
                currentLine.setEndX(e.getX());
                currentLine.setEndY(e.getY());

            }

        });
        root.setOnMouseReleased(e->{
            if (currentLine != null) {

                Double VectorX = cueBall.getX() - e.getX();
                Double VectorY = cueBall.getY() - e.getY();
                Double Magnitude = Math.sqrt((Math.pow(VectorX, 2) + Math.pow(VectorY, 2)));
                Double UnitVectorX = (VectorX / (Magnitude / 0.55));
                Double UnitVectorY = (VectorY / (Magnitude / 0.55));
                // System.out.println("X " + UnitVectorX + ", Y "+ UnitVectorY + "Magnitude" + Magnitude);

                root.getChildren().remove(currentLine);
                if (cueBall.getVelocityX() == 0.0 && cueBall.getVelocityY() == 0.0) {
                    cueBall.setVelocityX(Magnitude * UnitVectorX);
                    cueBall.setVelocityY(Magnitude * UnitVectorY);
                    // System.out.println(cueBall.getVelocityX());
                    //System.out.println(cueBall.getVelocityY());
                }
            }
        });
    }

    public void cueBallMovement(Group root){

    }

    public static List<Circle> generateCircle(List<Ball> BallsInPlay){
        List<Circle> circles = new ArrayList<Circle>();
        for (Ball ball : BallsInPlay){
            if (ball.return_colour().equals("BLUE")){
                //System.out.println("BLUE");
                //make blue circle
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("BLUE"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("RED")){
                //Make red circle
                //System.out.println("RED");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("RED"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("WHITE")){
                //System.out.println("WHITE");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("WHITE"));
                circles.add(circle);
            }
        }

        return circles;
    }
    public static ArrayList<Circle> generatePocketsToCircles(ArrayList<Pockets> pocketList){
        ArrayList<Circle> circles = new ArrayList<Circle>();
        for (Pockets pocket : pocketList){
            Circle circle = new Circle(pocket.getX(), pocket.getY(), pocket.getRadius());
            circles.add(circle);
        }
        return circles;
    }

    public static Pair<Point2D, Point2D> calculateCollision(Point2D positionA, Point2D velocityA, double massA, Point2D positionB, Point2D velocityB, double massB) {
        Point2D collisionVector = positionA.subtract(positionB);
        collisionVector = collisionVector.normalize();
        double vA = collisionVector.dotProduct(velocityA);
        double vB = collisionVector.dotProduct(velocityB);
        if (vB <= 0 && vA >= 0) {
            return new Pair<>(velocityA, velocityB);
        }
        double optimizedP = (2.0 * (vA - vB)) / (massA + massB);
        Point2D velAPrime = velocityA.subtract(collisionVector.multiply(optimizedP).multiply(massB));
        Point2D velBPrime = velocityB.add(collisionVector.multiply(optimizedP).multiply(massA));

        return new Pair<>(velAPrime, velBPrime);
    }



}
