/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package java_pool_game;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Scene;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;
import javafx.scene.Group;
import javafx.scene.canvas.Canvas;
import javafx.util.Duration;
import javafx.util.Pair;

import java.util.ArrayList;


public class App extends Application{
    private static final double KEY_FRAME_DURATION = 0.017;
    private ArrayList<Ball> ballsInPlay;
    private Ball cueBall;
    private Line currentLine;
    public App(){
    }
    @Override
    public void start(Stage primaryStage){
        //Sets up the ConfigReader and reads from the path specified
        ConfigReader config = new ConfigReader("config.json");
        System.out.println(config.path);
        config.parse();
        this.ballsInPlay = config.returnBalls();
        primaryStage.setTitle("Pool_game");
        //primaryStage.setResizable(false);
        //primaryStage.setWidth(config.boardX());
        //primaryStage.setHeight(config.boardX());


        //Creates the JavaFX scene and paints background depending on config
        Group root = new Group();
        Scene scene = new Scene(root);
        scene.setFill(Paint.valueOf(config.returnBoardColour()));

        //Configure canvas to config size
        Canvas canvas = new Canvas(config.boardX(), config.boardY());

        //canvas.setWidth(config.boardX());
        System.out.println(config.boardX());
        //Generate balls from the config file. These circles translate the balls objects to circles displayed
        ArrayList<Circle> circ = generateCircle(ballsInPlay);
        GeneratePockets Gen = new GeneratePockets();
        ArrayList<Pockets> pocketList = Gen.GeneratePocketList(config.boardX(), config.boardY(), (long) (config.getRadius()*1.7));
        //Changes pocket objects into Circle objects
        ArrayList<Circle> pockets = generatePocketsToCircles(pocketList);
        for (Ball ball: ballsInPlay){
            if (ball.return_colour().equals("WHITE")){
                this.cueBall = ball;
            }
        }




        //https://mkyong.com/javafx/javafx-animated-ball-example/
        //http://www.java2s.com/Code/Java/JavaFX/KeyFrameandTimelinebasedanimation.htm
        /*scene.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                System.out.println("mouse click detected! " + mouseEvent.getSource());
                System.out.println(cueBall.getX() +", " + cueBall.getY());
            }
        });
        scene.addEventFilter(MouseEvent.)
        */

        mouseEvents(root);

        primaryStage.setScene(scene);
        root.getChildren().add(canvas);
        root.getChildren().addAll(circ);
        root.getChildren().addAll(pockets);
        primaryStage.show();

        /*Bounds bounds = canvas.getBoundsInLocal();
        Timeline animationLoop = new Timeline();
        animationLoop.setCycleCount(Timeline.INDEFINITE);
        KeyFrame frame = new KeyFrame(Duration.seconds(KEY_FRAME_DURATION),
                new EventHandler<ActionEvent>() {
                    @Override
                    public void handle(ActionEvent event) {
                        int dx = 1;
                        int dy = 1;
                        Circle circle = circ.get(0);
                        Double xMin = circle.getBoundsInParent().getMinX();
                        Double yMin = circle.getBoundsInParent().getMinY();
                        Double xMax = circle.getBoundsInParent().getMaxX();
                        Double yMax = circle.getBoundsInParent().getMaxY();
                        if (xMin < 0 || xMax > scene.getWidth()) {
                            dx = dx * -1;
                        }
                        if (yMin < 0 || yMax > scene.getHeight()) {
                            dy = dy * -1;
                        }

                        circle.setTranslateX(circle.getTranslateX() + dx);
                        circle.setTranslateY(circle.getTranslateY() + dy);

                    }
                });
        animationLoop.getKeyFrames().add(frame);
        animationLoop.play();*/



    }
    public static void main(String[] args){
        launch(args);

    }

    public void mouseEvents(Group root){
        root.setOnMousePressed(e -> {
            if (currentLine == null) {
                currentLine = new Line(cueBall.getX(), cueBall.getY(), e.getX(), e.getY());
                root.getChildren().add(currentLine);
            } else {
                currentLine = null ;
            }
        });

        root.setOnMouseDragged(e -> {
            if (currentLine != null) {
                currentLine.setEndX(e.getX());
                currentLine.setEndY(e.getY());

            }

        });
        root.setOnMouseReleased(e->{
            if (currentLine != null){
                Double xLen = Math.pow(cueBall.getX()-e.getX(), 2);
                Double yLen = Math.pow(cueBall.getY()- e.getY(), 2);
                Double EuclideanDistance = Math.sqrt(xLen+yLen);
                Double VectorX = cueBall.getX()-e.getX();
                Double VectorY = cueBall.getY()-e.getY();
                Double Magnitude = Math.sqrt((Math.pow(VectorX, 2)+Math.pow(VectorY,2)));
                Double UnitVectorX = VectorX/Magnitude;
                Double UnitVectorY = VectorY/Magnitude;
                System.out.println("X " + UnitVectorX + ", Y "+ UnitVectorY + "Strength "+ EuclideanDistance);

                root.getChildren().remove(currentLine);
                cueBall.setVelocityX(EuclideanDistance*VectorX);
                cueBall.setVelocityY(EuclideanDistance*VectorY);
            }
        });

    }

    public static ArrayList<Circle> generateCircle(ArrayList<Ball> BallsInPlay){
        ArrayList<Circle> circles = new ArrayList<Circle>();
        for (Ball ball : BallsInPlay){
            if (ball.return_colour().equals("BLUE")){
                System.out.println("BLUE");
                //make blue circle
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("BLUE"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("RED")){
                //Make red circle
                System.out.println("RED");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("RED"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("WHITE")){
                System.out.println("WHITE");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("WHITE"));
                circles.add(circle);
            }
        }

        return circles;
    }
    public static ArrayList<Circle> generatePocketsToCircles(ArrayList<Pockets> pocketList){
        ArrayList<Circle> circles = new ArrayList<Circle>();
        for (Pockets pocket : pocketList){
            Circle circle = new Circle(pocket.getX(), pocket.getY(), pocket.getRadius());
            circles.add(circle);
        }
        return circles;
    }


    /**
     * This is an updated collision calculation function for 2 balls colliding in 2D space. You may use it however
     * you wish for your assignment.
     *
     * This uses the optimised physics algorithm discussed here:
     * http://www.gamasutra.com/view/feature/3015/pool_hall_lessons_fast_accurate_.php?page=3
     * which has been converted into Java/JavaFX
     *
     * @param positionA The coordinates of the centre of ball A
     * @param velocityA The delta x,y vector of ball A (how much it moves per tick)
     * @param massA The mass of ball A (for the moment this should always be the same as ball B)
     * @param positionB The coordinates of the centre of ball B
     * @param velocityB The delta x,y vector of ball B (how much it moves per tick)
     * @param massB The mass of ball B (for the moment this should always be the same as ball A)
     *
     * @return A Pair<Point2D, Point2D> in which the first (key) Point2D is the new delta x,y vector for ball A, and the second (value) Point2D is the new delta x,y vector for ball B.
     */
    public static Pair<Point2D, Point2D> calculateCollision(Point2D positionA, Point2D velocityA, double massA, Point2D positionB, Point2D velocityB, double massB) {

        // Find the angle of the collision - basically where is ball B relative to ball A. We aren't concerned with
        // distance here, so we reduce it to unit (1) size with normalize() - this allows for arbitrary radii
        Point2D collisionVector = positionA.subtract(positionB);
        collisionVector = collisionVector.normalize();

        // Here we determine how 'direct' or 'glancing' the collision was for each ball
        double vA = collisionVector.dotProduct(velocityA);
        double vB = collisionVector.dotProduct(velocityB);

        // If you don't detect the collision at just the right time, balls might collide again before they leave
        // each others' collision detection area, and bounce twice.
        // This stops these secondary collisions by detecting
        // whether a ball has already begun moving away from its pair, and returns the original velocities
        if (vB <= 0 && vA >= 0) {
            return new Pair<>(velocityA, velocityB);
        }

        // This is the optimisation function described in the gamasutra link. Rather than handling the full quadratic
        // (which as we have discovered allowed for sneaky typos)
        // this is a much simpler - and faster - way of obtaining the same results.
        double optimizedP = (2.0 * (vA - vB)) / (massA + massB);

        // Now we apply that calculated function to the pair of balls to obtain their final velocities
        Point2D velAPrime = velocityA.subtract(collisionVector.multiply(optimizedP).multiply(massB));
        Point2D velBPrime = velocityB.add(collisionVector.multiply(optimizedP).multiply(massA));

        return new Pair<>(velAPrime, velBPrime);
    }


}
