/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package java_pool_game;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Scene;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;
import javafx.scene.Group;
import javafx.scene.canvas.Canvas;
import javafx.util.Duration;
import javafx.util.Pair;

import java.util.ArrayList;


public class App extends Application{
    private static final double KEY_FRAME_DURATION = 0.017;
    private ArrayList<Ball> ballsInPlay;
    public App(){

    }
    @Override
    public void start(Stage primaryStage){
        //Sets up the ConfigReader and reads from the path specified
        ConfigReader config = new ConfigReader("config.json");
        config.parse();
        this.ballsInPlay = config.returnBalls();
        primaryStage.setTitle("Assignment_2_Pool_game");

        //Creates the JavaFX scene and paints background depending on config
        Group root = new Group();
        Scene scene = new Scene(root);
        scene.setFill(Paint.valueOf(config.returnBoardColour()));

        //Configure canvas to config size
        Canvas canvas = new Canvas(config.boardX(), config.boardY());

        //Generate balls from the config file. These circles translate the balls objects to circles displayed
        ArrayList<Circle> circ = generateCircle(ballsInPlay);



//https://mkyong.com/javafx/javafx-animated-ball-example/
        //http://www.java2s.com/Code/Java/JavaFX/KeyFrameandTimelinebasedanimation.htm
        primaryStage.setScene(scene);
        root.getChildren().add(canvas);
        root.getChildren().addAll(circ);
        primaryStage.show();

        /*Bounds bounds = canvas.getBoundsInLocal();
        Timeline animationLoop = new Timeline();
        animationLoop.setCycleCount(Timeline.INDEFINITE);
        KeyFrame frame = new KeyFrame(Duration.seconds(KEY_FRAME_DURATION),
                new EventHandler<ActionEvent>() {
                    @Override
                    public void handle(ActionEvent event) {
                        int dx = 1;
                        int dy = 1;
                        Circle circle = circ.get(0);
                        Double xMin = circle.getBoundsInParent().getMinX();
                        Double yMin = circle.getBoundsInParent().getMinY();
                        Double xMax = circle.getBoundsInParent().getMaxX();
                        Double yMax = circle.getBoundsInParent().getMaxY();
                        if (xMin < 0 || xMax > scene.getWidth()) {
                            dx = dx * -1;
                        }
                        if (yMin < 0 || yMax > scene.getHeight()) {
                            dy = dy * -1;
                        }

                        circle.setTranslateX(circle.getTranslateX() + dx);
                        circle.setTranslateY(circle.getTranslateY() + dy);

                    }
                });
        animationLoop.getKeyFrames().add(frame);
        animationLoop.play();*/



    }
    public static void main(String[] args){
        launch(args);

    }

    public static ArrayList<Circle> generateCircle(ArrayList<Ball> BallsInPlay){
        ArrayList<Circle> circles = new ArrayList<Circle>();
        for (Ball ball : BallsInPlay){
            if (ball.return_colour().equals("BLUE")){
                System.out.println("BLUE");
                //make blue circle
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("BLUE"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("RED")){
                //Make red circle
                System.out.println("RED");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("RED"));
                circles.add(circle);
            }
            else if (ball.return_colour().equals("WHITE")){
                System.out.println("WHITE");
                Circle circle = new Circle(ball.getX(), ball.getY(), ball.radius);
                circle.setFill(Paint.valueOf("WHITE"));
                circles.add(circle);
            }
        }

        return circles;
    }

    /**
     * This is an updated collision calculation function for 2 balls colliding in 2D space. You may use it however
     * you wish for your assignment.
     *
     * This uses the optimised physics algorithm discussed here:
     * http://www.gamasutra.com/view/feature/3015/pool_hall_lessons_fast_accurate_.php?page=3
     * which has been converted into Java/JavaFX
     *
     * @param positionA The coordinates of the centre of ball A
     * @param velocityA The delta x,y vector of ball A (how much it moves per tick)
     * @param massA The mass of ball A (for the moment this should always be the same as ball B)
     * @param positionB The coordinates of the centre of ball B
     * @param velocityB The delta x,y vector of ball B (how much it moves per tick)
     * @param massB The mass of ball B (for the moment this should always be the same as ball A)
     *
     * @return A Pair<Point2D, Point2D> in which the first (key) Point2D is the new delta x,y vector for ball A, and the second (value) Point2D is the new delta x,y vector for ball B.
     */
    public static Pair<Point2D, Point2D> calculateCollision(Point2D positionA, Point2D velocityA, double massA, Point2D positionB, Point2D velocityB, double massB) {

        // Find the angle of the collision - basically where is ball B relative to ball A. We aren't concerned with
        // distance here, so we reduce it to unit (1) size with normalize() - this allows for arbitrary radii
        Point2D collisionVector = positionA.subtract(positionB);
        collisionVector = collisionVector.normalize();

        // Here we determine how 'direct' or 'glancing' the collision was for each ball
        double vA = collisionVector.dotProduct(velocityA);
        double vB = collisionVector.dotProduct(velocityB);

        // If you don't detect the collision at just the right time, balls might collide again before they leave
        // each others' collision detection area, and bounce twice.
        // This stops these secondary collisions by detecting
        // whether a ball has already begun moving away from its pair, and returns the original velocities
        if (vB <= 0 && vA >= 0) {
            return new Pair<>(velocityA, velocityB);
        }

        // This is the optimisation function described in the gamasutra link. Rather than handling the full quadratic
        // (which as we have discovered allowed for sneaky typos)
        // this is a much simpler - and faster - way of obtaining the same results.
        double optimizedP = (2.0 * (vA - vB)) / (massA + massB);

        // Now we apply that calculated function to the pair of balls to obtain their final velocities
        Point2D velAPrime = velocityA.subtract(collisionVector.multiply(optimizedP).multiply(massB));
        Point2D velBPrime = velocityB.add(collisionVector.multiply(optimizedP).multiply(massA));

        return new Pair<>(velAPrime, velBPrime);
    }


}
